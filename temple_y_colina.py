# -*- coding: utf-8 -*-
"""Temple y Colina

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a4ku7g-TzZgUUq3MpS2pnJ96lnkpatkn
"""

import numpy as np
import matplotlib.pyplot as plt
import random

def dibujar_tablero(reinas):
    tablero = np.zeros((8, 8))
    for columna, fila in enumerate(reinas):
        tablero[fila, columna] = 1
    plt.figure(figsize=(6, 6))
    plt.imshow(tablero, cmap="binary")
    for columna, fila in enumerate(reinas):
        plt.text(columna, fila, '♛', ha='center', va='center', fontsize=20, color="red")
    plt.xticks(range(8))
    plt.yticks(range(8))
    plt.grid(True)
    plt.show()

def ocho_reinas_ascenso_colinas():
    def evaluar(reinas):
        conflictos = 0
        for i in range(len(reinas)):
            for j in range(i + 1, len(reinas)):
                if reinas[i] == reinas[j] or abs(reinas[i] - reinas[j]) == j - i:
                    conflictos += 1
        return conflictos

    reinas = list(range(8))
    random.shuffle(reinas)
    costo_actual = evaluar(reinas)

    while costo_actual > 0:
        dibujar_tablero(reinas)
        mejorado = False
        for columna in range(8):
            for fila in range(8):
                if fila != reinas[columna]:
                    nuevas_reinas = reinas[:]
                    nuevas_reinas[columna] = fila
                    nuevo_costo = evaluar(nuevas_reinas)
                    if nuevo_costo < costo_actual:
                        reinas, costo_actual = nuevas_reinas, nuevo_costo
                        mejorado = True
                        break
            if mejorado:
                break
        if not mejorado:
            break

    dibujar_tablero(reinas)
    return reinas

solucion = ocho_reinas_ascenso_colinas()
print("Solución encontrada:", solucion)

import matplotlib.pyplot as plt
import random

def agente_viajero_ascenso_colinas(distancias):
    n = len(distancias)
    solucion_actual = list(range(n))
    random.shuffle(solucion_actual)

    distancia_actual = sum(distancias[solucion_actual[i]][solucion_actual[i + 1]] for i in range(n - 1)) + distancias[solucion_actual[-1]][solucion_actual[0]]
    mejor_solucion = solucion_actual[:]
    mejor_distancia = distancia_actual

    for _ in range(1000):
        vecino = solucion_actual[:]
        idx1, idx2 = random.sample(range(n), 2)
        vecino[idx1], vecino[idx2] = vecino[idx2], vecino[idx1]

        nueva_distancia = sum(distancias[vecino[i]][vecino[i + 1]] for i in range(n - 1)) + distancias[vecino[-1]][vecino[0]]

        if nueva_distancia < distancia_actual:
            solucion_actual, distancia_actual = vecino, nueva_distancia
            mejor_solucion = solucion_actual[:]
            mejor_distancia = distancia_actual

    plt.figure(figsize=(8, 6))
    for i in range(n):
        plt.plot([i, (i + 1) % n], [mejor_solucion[i], mejor_solucion[(i + 1) % n]], 'bo-')
    plt.title('Ruta del Agente Viajero (Ascenso de Colinas)')
    plt.xlabel('Ciudades')
    plt.ylabel('Ruta')
    plt.xticks(range(n))
    plt.grid()
    plt.show()

    return mejor_solucion, mejor_distancia

distancias = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]

solucion, distancia = agente_viajero_ascenso_colinas(distancias)
print("Mejor ruta encontrada:", solucion)
print("Distancia total:", distancia)

import random
import math
import matplotlib.pyplot as plt

# ================================
# Funciones auxiliares
# ================================

def generar_estado(n=8):
    """Genera un estado inicial aleatorio (una reina por columna en una fila aleatoria)."""
    return [random.randint(0, n-1) for _ in range(n)]

def calcular_conflictos(tablero):
    """Calcula el número de conflictos en un tablero."""
    n = len(tablero)
    conflictos = 0
    for i in range(n):
        for j in range(i+1, n):
            if tablero[i] == tablero[j] or abs(tablero[i] - tablero[j]) == abs(i - j):
                conflictos += 1
    return conflictos

def generar_vecino(tablero):
    """Genera un vecino modificando aleatoriamente la posición de una reina."""
    n = len(tablero)
    vecino = tablero[:]
    col = random.randint(0, n-1)
    fila = random.randint(0, n-1)
    vecino[col] = fila
    return vecino

# ================================
# Temple Simulado
# ================================

def temple_simulado(n=8, temp_inicial=1000, temp_final=0.01, alfa=0.99, max_iter=1000):
    """Implementa Temple Simulado para resolver el problema de las N-Reinas."""

    estado_actual = generar_estado(n)
    mejor_estado = estado_actual
    temp = temp_inicial

    while temp > temp_final:
        for _ in range(max_iter):
            vecino = generar_vecino(estado_actual)
            delta = calcular_conflictos(estado_actual) - calcular_conflictos(vecino)

            if delta > 0:  # Si mejora, aceptamos
                estado_actual = vecino
            else:  # Si empeora, aceptamos con probabilidad exp(delta/temp)
                if random.random() < math.exp(delta / temp):
                    estado_actual = vecino

            if calcular_conflictos(estado_actual) < calcular_conflictos(mejor_estado):
                mejor_estado = estado_actual

            # Si encontramos solución sin conflictos, terminamos
            if calcular_conflictos(mejor_estado) == 0:
                return mejor_estado

        temp *= alfa  # Reducimos la temperatura

    return mejor_estado

# ================================
# Visualización de tablero
# ================================

def dibujar_tablero(tablero):
    n = len(tablero)
    fig, ax = plt.subplots()
    # Dibujar tablero
    for i in range(n):
        for j in range(n):
            color = 'cornsilk' if (i+j) % 2 == 0 else 'saddlebrown'
            ax.add_patch(plt.Rectangle((j, n-1-i), 1, 1, color=color))

    # Dibujar reinas
    for col, fila in enumerate(tablero):
        ax.text(col+0.5, n-1-fila+0.5, "♛", fontsize=28, ha='center', va='center', color="black")

    ax.set_xlim(0, n)
    ax.set_ylim(0, n)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal')
    plt.show()

# ================================
# Ejecución
# ================================

if __name__ == "__main__":
    solucion = temple_simulado()
    print("Solución encontrada:", solucion)
    print("Conflictos:", calcular_conflictos(solucion))
    dibujar_tablero(solucion)

import random
import math
import matplotlib.pyplot as plt

# ================================
# Funciones auxiliares
# ================================

def generar_ciudades(n=10, ancho=100, alto=100):
    """Genera n ciudades con coordenadas aleatorias en un plano."""
    return [(random.randint(0, ancho), random.randint(0, alto)) for _ in range(n)]

def distancia(ciudad1, ciudad2):
    """Distancia euclidiana entre dos ciudades."""
    return math.sqrt((ciudad1[0]-ciudad2[0])**2 + (ciudad1[1]-ciudad2[1])**2)

def calcular_longitud(ruta, ciudades):
    """Calcula la longitud total de una ruta."""
    total = 0
    for i in range(len(ruta)):
        ciudad_actual = ciudades[ruta[i]]
        ciudad_siguiente = ciudades[ruta[(i+1) % len(ruta)]]  # ciclo
        total += distancia(ciudad_actual, ciudad_siguiente)
    return total

def generar_estado(n):
    """Genera una ruta inicial aleatoria."""
    ruta = list(range(n))
    random.shuffle(ruta)
    return ruta

def generar_vecino(ruta):
    """Genera un vecino intercambiando dos ciudades de la ruta."""
    a, b = random.sample(range(len(ruta)), 2)
    vecino = ruta[:]
    vecino[a], vecino[b] = vecino[b], vecino[a]
    return vecino

# ================================
# Temple Simulado
# ================================

def temple_simulado(ciudades, temp_inicial=1000, temp_final=0.01, alfa=0.99, max_iter=500):
    """Temple Simulado para el TSP."""
    estado_actual = generar_estado(len(ciudades))
    mejor_estado = estado_actual
    temp = temp_inicial

    while temp > temp_final:
        for _ in range(max_iter):
            vecino = generar_vecino(estado_actual)
            delta = calcular_longitud(estado_actual, ciudades) - calcular_longitud(vecino, ciudades)

            if delta > 0:  # mejora
                estado_actual = vecino
            else:  # acepta con probabilidad
                if random.random() < math.exp(delta / temp):
                    estado_actual = vecino

            if calcular_longitud(estado_actual, ciudades) < calcular_longitud(mejor_estado, ciudades):
                mejor_estado = estado_actual

        temp *= alfa

    return mejor_estado

# ================================
# Visualización de la ruta
# ================================

def dibujar_ruta(ruta, ciudades):
    x = [ciudades[i][0] for i in ruta] + [ciudades[ruta[0]][0]]
    y = [ciudades[i][1] for i in ruta] + [ciudades[ruta[0]][1]]

    plt.figure(figsize=(6,6))
    plt.scatter([c[0] for c in ciudades], [c[1] for c in ciudades], c="red", s=100, label="Ciudades")
    plt.plot(x, y, 'b-', lw=1.5, label="Ruta")
    for i, ciudad in enumerate(ciudades):
        plt.text(ciudad[0]+1, ciudad[1]+1, str(i), fontsize=12)

    plt.title("Ruta encontrada con Temple Simulado (TSP)")
    plt.legend()
    plt.show()

# ================================
# Ejecución
# ================================

if __name__ == "__main__":
    ciudades = generar_ciudades(10)  # puedes cambiar el número de ciudades
    solucion = temple_simulado(ciudades)
    print("Ruta encontrada:", solucion)
    print("Longitud total:", calcular_longitud(solucion, ciudades))
    dibujar_ruta(solucion, ciudades)